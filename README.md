# Node.JS
# 1.1  노드란
노드는 자바스크립트 런타임으로 자바스크립트 엔진인 V8로 빌드됐다.
* 노드는 서버가 아니다. 서버의 역할을 수행할 수 있고 자바스크립트로 작성된 소스 코드를 실행하는 런타임이다.
`런타임이란 쉽게 말해 실행기를 뜻한다.`
* 노드는 멀티 스레드 방식을 사용할 수 있지만 주로 싱글 스레드를 사용한다. 싱글 스레드의 방식을 치명적인 단점을 보완하기 위해 논블로킹 방식을 채택했다.

# 1.2 스레드와 논블로킹이란

프로세스 - 운영체제 내에서 할당하는 작업의 단위
스레드 - 프로세스 내에서 실행되는 작업의 단위
#### 싱글 스레드란
* 프로세스 내에서 실행되는 단위가 한 개이다. 즉, **프로세스**라는 식당의 직원의 수가 한 명이다. CPU 내의 여러 코어들 중 단 한 개만 사용한다는 뜻이고 코어가 32개라 했을 때 1개는 엄청 뜨거운 반면 나머지 31개는 차가운 상태를 유지한다는 것이다.
* 싱글스레드는 멀티스레드보다 효율성이 낮다. 하지만 멀티 스레드는 코딩 난이도가 높은 반면 싱글스레드는 상대적으로 매우 낮다. 멀티 스레드가 되는 다른 언어를 사용하는 대신 노드를 사용하는 가장 큰 이유이다. *

#### 논블로킹이란
일부 코드를 백그라운드(다른 프로세스)에서 실행하는 방식이다.
* 멀티스레드가 한 식당에서 여러 명의 직원을 고용하여 손님의 주문을 처리한다면 싱글스레드의 논 블로킹 방식은 여러 식당에서 한 명의 직원 고용하여 손님의 주문을 처리하는 방식이다. 

# 1.3 서버로서의 노드
서버: 네트워크를 통해 클라이언트에게 정보나 서비스를 제공하는 컴퓨터 또는 프로그램
클라이언트: 서버에게 요청을 보내는 주체(브라우저, 데스크탑 프로그램, 모바일 앱, 한 서버에서 서버로)

#### 노드의 장단점
|<center>장점</center>|<center>단점</center>|
|---|---|
|싱글 스레드 방식에 비해 컴퓨터 자원을 적게 사용함|싱글 스레드라서 코어를 하나만 사용함|
|멀티 스레드 방식보다 쉬움|하나뿐인 스레드가 쉬지 않도록 해야함|
|자바스크립트를 사용함|어중간한 성능|
|웹서버가 내장되어있음|서버 규모가 커졌을 때 관리하기 어려움|
|JSON 형식과 호환하기 쉬움| &nbsp;|
#### 서버 외의 노드
노드는 자바스크립트 런타임이기 때문에 용도가 서버에만 국한 되지 않는다.
웹, 모바일, 데스크탑 애플케이션에서도 사용
* 웹 프레임워크 - Angular, React, Vue, Meteor 등
* 모바일 웹 framework - React Native 등
* 데스크탑 개발 도구: Electron(Atom, Slack, VScode, Discord 등 제작)

# Node.js 기능
# 2.1 모듈 만들기
#### 외부 파일의 변수 사용

assi.js 파일을 만들어 다음 코드를 작성해보자
```
const add = 'Hi';
const min = 'By';

module.exports = {
    add,
    min,
};
```
선언된 add와 min 변수를 **module.exports에 할당**하여 객체를 사용할 수 있다. 파일을 모듈화할 수 있다.

main.js 파일을 통해 변수를 사용해보자
```
const value = require('./assi');
console.log(value);
```
module.export에 할당한 객체는 `변수 = require('경로')`를 통해 외부파일에서 사용할 수 있다.
require은 node에서 제공하는 함수이다.
```
{ add: 'Hi', min: 'By' }
```
* require('./assi') 구조에서 온점(.)은 현재 위치를 뜻한다.
* 구조 분해를 통해서 객체를 받을 수 있다.  **단, 구조 분해 할당을 할 때는 속성명과 변수명이 같아야한다.**
ex)
```
const { min, add } = require('./assi');
console.log(min, add);
```
* 이미 객체 변수를 할당한 다음 또다시 변수를 할당하면 기존의 참조관계가 사라진다.

#### fs 모듈 사용
fs 모듈을 사용하기 위해서는 fs모듈을 불러와야한다. 
```
const fs = require('fs');

```
* fs. readfile('경로') - 파일을 불러올 수 있다.

### 혼란을 주거나 이해하기 힘들었던 개념, 오류
* **favicon.ico 존재** 
		어떤 페이지를 새로고침해도 뜨는 favicon.ico는 무엇인가
favicon.ico는 크롬에서 보내는 요청으로 favicon이 있는지 확인하는 요청이다. 신경쓸 필요는 없다. **favicon**은 페이지의 이름 옆에 있는 아이콘이다. 
inject.js 또한 마찬가지로 확장 프로그램에서 보내는 요청으로 신경쓸 필요는 없다.

* **cookie의 값에 한글 **[ERROR]
		cookie에 한글을 넣을 시 오류가 발생한다. 어떻게 해결해야하나
쿠키에 집어넣을 값을 encodeURIComponent(값) 통해 한글로 된 정보의 형태를 변환하여 해결한다.

### 혼란을 주거나 이해가 힘들었던 명령어

* **http 모듈**
		NodeJS 입문 과정에서 겪은 문제로, require('http') 에서 require이 모듈을 불러오는 것까지는 알지만 http 모듈이 정확히 뭘하는 모듈인가
http 모듈은 Node.js의 기본 모듈로 http 웹 서버와 클라이언트를 생성하는 것과 관련된 모든 기능를 당담한다.

### 알면 좋고 모르면 안좋은 기능들(무조건 기록해야돼)

* **Cookie 삭제**
		쿠키를 삭제 할 때는 application > storage > cookies 에서 페이지마다 x를 눌러서 캐시를 삭제할 수 있다. 클릭 한 번이면 충분하지만 귀찮은 작업이니 되도록 실수하지 않도록하자


# Node.js 서버

# 3.1 노드 서버 만들기

#### 서버와 클라이언트의 관계
*  1) 서버는 클라이언트에게 **요청(request)**을 받음
*  2) 서버가 요청을 처리함
* 3) 서버가 **답변(reponse)**을 보냄

#### 간단한 서버 만들기
```
const http = require('http');

const Server = http.createServer((req, res) => {
    res.write('<h1>Hello Node!</h1>');
    res.write('<p>Hello server</p>');
    res.end('<p>Hello Client!</p>');
})
```

#### RestAPI

서버 자원 정리, 자원의 주소 지정하는 방법
* 서버가 이해하기 쉬운 주소가 좋음

* Http 요청 메서드

**GET:** 서버 자원을 가져오려고 할 때 사용
**POST:** 서버에 자원을 새로 등록하고자 할 때 사용
**PUT:** 서버의 자원을 요청에 들어있는 자원으로 치환하고자 할 때 사용
**PATCH:** 서버 자원의 일부만 수정하고자 할 때 사용
**DELETE:** 서버 자원을 삭제하고자 할 때 사용

* RESTful : REST API를 사용한 주소 체계를 이용하는 서버

#### HTTP 프로토콜
데이터 통신을 원활하게 하기 위한 통신 규약
* 클라이언트가 누구든 HTTP 프로토콜로 소통 가능

#### Cookie 서버 만들기

Cookie란 키=값의 쌍으로 매요청(request)마다 서버는 Cookie를 동봉해서 답변(response)을 보낸다

* **Cookie를 넣는것을 직접 구현**
**writeHead():** 요청 헤더에 입력하는 매서드
**Set-Cookie:** 브라우저에게 쿠키를 설정하라고 명령

#### Http 통신의 헤더와 본문
모든 http 통신은 헤더와 본문을 가진다.
* 헤더는 요청 또는 응답에 대한 정보를 가진다
* 본문은 주고받는 실제 데이터.
* cookie는 부가적인 정보이므로 헤더에 들어간다

#### Http 상태 코드
writeHead 매서드에 첫 번째 인수로 넣는 값.
**요청의 성공과 실패**를 알려준다.
* 2xx는 **성공을 알리는 상태 코드**. 대표적으로 200(성공), 201(작성됨)이 자주 사용된다.
* 3xx는 **리다이렉션의 상태를 알려주는 상태 코드** 대표적으로 301(영구 이동), 302(임시 이동)이 있다.
* 4xx는 **요청 오류**를 나타낸다. 요청 자체의 오류가 있을때 표시된다.. 대표적으로 401(권한 없음), 403(금지됨), 404(찾을 수 없음)이 있다.
* 5xx는 요청은 제대로 왔지만 **서버에 오류**가 생겼을 때 발생한다. 대표적으로 500(내부 서버 오류), 502(불량 게이트웨이), 503(서비스를 사용할 수 없음)이 자주 사용된다.
